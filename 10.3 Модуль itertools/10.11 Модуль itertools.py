#  10.11 Модуль itertools
""""""


"""   *   *   *   Task   *   *   *   """


#  10.11-1
"""
доступен именованный кортеж Person, который содержит данные о человеке. 
Первым элементом именованного кортежа является имя человека, вторым — возраст, третьим — рост. 
Также доступен список persons, содержащий эти кортежи.

Дополните приведенный ниже код, чтобы он сгруппировал людей из данного списка по их росту 
и вывел полученные группы. 
Для каждой группы сначала должен быть указан рост, а затем через запятую перечислены имена людей, 
имеющих соответствующий рост. 
Группы должны быть расположены в порядке увеличения роста, каждая на отдельной строке, 
имена в группах — в алфавитном порядке, в следующем формате:
<рост>: <имя>, <имя>, ...
"""
from collections import namedtuple
from itertools import groupby

Person = namedtuple('Person', ['name', 'age', 'height'])

persons = [Person('Tim', 63, 193), Person('Eva', 47, 158),
           Person('Mark', 71, 172), Person('Alex', 45, 193),
           Person('Jeff', 63, 193), Person('Ryan', 41, 184),
           Person('Ariana', 28, 158), Person('Liam', 69, 193)]


persons.sort(key=lambda x: x.height)
data = groupby(persons, key=lambda y: y.height)
for key, val in data:
    names = sorted(el.name for el in val)
    print(f"{key}: {', '.join(names)}")


# Вариант
res = groupby(sorted(persons, key=lambda x: x.height), key=lambda y: y.height)
for key, val in res:
    print(f'{key}: {", ".join(sorted(el.name for el in val))}')

# 158: Ariana, Eva
# 172: Mark
# 184: Ryan
# 193: Alex, Jeff, Liam, Tim


#  10.11-2
"""
Доступен именованный кортеж Student, который содержит данные об ученике. 
Первым элементом именованного кортежа является фамилия ученика, вторым — имя, третьим — класс. 
Также доступен список students, содержащий эти кортежи.
Дополните приведенный ниже код, чтобы он вывел наиболее часто встречаемое имя среди учеников из данного списка.
Гарантируется, что искомое имя единственное.
"""
from collections import namedtuple
from itertools import groupby

Student = namedtuple('Student', ['surname', 'name', 'grade'])

students = [Student('Гагиев', 'Александр', 10), Student('Дедегкаев', 'Илья', 11), Student('Кодзаев', 'Георгий', 10),
            Student('Набокова', 'Алиса', 11), Student('Кораев', 'Артур', 10), Student('Шилин', 'Александр', 11),
            Student('Уртаева', 'Илина', 11), Student('Салбиев', 'Максим', 10), Student('Капустин', 'Илья', 11),
            Student('Гудцев', 'Таймураз', 11), Student('Перчиков', 'Максим', 10), Student('Чен', 'Илья', 11),
            Student('Елькина', 'Мария', 11),Student('Макоев', 'Руслан', 11), Student('Албегов', 'Хетаг', 11),
            Student('Щербак', 'Илья', 10), Student('Идрисов', 'Баграт', 11), Student('Гапбаев', 'Герман', 10),
            Student('Цивинская', 'Анна', 10), Student('Туткевич', 'Юрий', 11), Student('Мусиков', 'Андраник', 11),
            Student('Гадзиев', 'Георгий', 11), Student('Белов', 'Юрий', 11), Student('Акоева', 'Диана', 11),
            Student('Денисов', 'Илья', 11), Student('Букулова', 'Диана', 10), Student('Акоева', 'Лера', 11)]


students.sort(key=lambda x: x.name)
data = groupby(students, key=lambda x: x.name)

print(max(data, key=lambda x: sum(1 for _ in x[1]))[0])
# Илья


#  10.11-3
"""
Группы слов
На вход программе подается последовательность слов, разделенных пробелом. 
Каждое слово записано строчными латинскими буквами.
Сгруппировать введенные слова по их длине и вывести полученные группы. 
Для каждой группы должна быть указана длина, 
а затем через запятую перечислены слова, имеющие соответствующую длину. 
Группы должны быть расположены в порядке увеличения длины, каждая на отдельной строке, 
слова в группах — в алфавитном порядке, в следующем формате:
<длина> -> <слово>, <слово>, ...

Input:  hi never here my blue
Output: 2 -> hi, my
        4 -> blue, here
        5 -> never
"""
from itertools import groupby

res = groupby(sorted(input().split(), key=len), key=len)
for k, v in res:
    print(f"{k} -> {', '.join(sorted(v))}")


#  10.11-4
"""
Нет дел
Доступен список tasks. Каждый элемент списка представляет собой кортеж из трех элементов: 
первый — название дела, второй — действие, третий — очередность.

Дополните приведенный ниже код, чтобы он вывел все дела в алфавитном порядке,
указав для каждого набор соответствующих действий в правильной очередности, в следующем формате:
<дело>:
    1. <действие>
    2. <действие>
    ...
Между двумя делами должна быть расположена пустая строка.

Output: ЕГЭ Математика:
        1. доделать курс по параметрам

        Курс по ооп:
            1. обсудить темы
            2. обсудить задачи

    ...
"""
from itertools import groupby

tasks = [('Отдых', 'поспать днем', 3),
         ('Ответы на вопросы', 'ответить на вопросы в дискорде', 1),
         ('ЕГЭ Математика', 'доделать курс по параметрам', 1),
         ('Ответы на вопросы', 'ответить на вопросы в курсах', 2),
         ('Отдых', 'погулять вечером', 4),
         ('Курс по ооп', 'обсудить темы', 1),
         ('Урок по groupby', 'добавить задачи на программирование', 3),
         ('Урок по groupby', 'написать конспект', 1),
         ('Отдых', 'погулять днем', 2),
         ('Урок по groupby', 'добавить тестовые задачи', 2),
         ('Уборка', 'убраться в ванной', 2),
         ('Уборка', 'убраться в комнате', 1),
         ('Уборка', 'убраться на кухне', 3),
         ('Отдых', 'погулять утром', 1),
         ('Курс по ооп', 'обсудить задачи', 2)]

tasks.sort(key=lambda x: (x[0], x[2]))
data = groupby(tasks, key=lambda x: x[0])
for key, val in data:
    print(f'{key}:')
    [print(f'\t{el[2]}. {el[1]}') for el in val]
    print()

# Короче
data = groupby(sorted(tasks, key=lambda x: (x[0], x[2])), key=lambda x: x[0])
for key, val in data:
    print(f'{key}:', *[f'\t{el[2]}. {el[1]}' for el in val], '', sep='\n')


#  10.11-5
"""
Функция group_anagrams()
Анаграммы — это слова, которые состоят из одинаковых букв. Например:
адаптер — петарда
азбука — базука

Реализуйте функцию group_anagrams(), которая принимает один аргумент:
words — список слов
Функция должна группировать в кортежи слова из списка words, являющиеся анаграммами, 
и возвращать список полученных кортежей.
Порядок кортежей в возвращаемом функцией списке, а также порядок элементов в этих кортежах, не важен.

Input:  *
Output: *
"""
from itertools import groupby
from collections import Counter

def group_anagrams(words):
    words.sort(key=sorted)
    words = groupby(words, key=sorted)
    return [tuple(val) for _, val in words]


# Вариант
def group_anagrams(words):
    words.sort(key=sorted)
    words = groupby(words, key=Counter)
    return (tuple(el[1]) for el in words)



groups = group_anagrams(['evil', 'father', 'live', 'levi', 'book', 'afther', 'boko'])
print(*groups)
# ('boko', 'book') ('evil', 'levi', 'live') ('afther', 'father')

# Что дает key=sorted - отсортированный новый список ['a', 'e', 'f', 'h', 'r', 't']
# return [f'{k}: {tuple(val)}' for k, val in words]
# ['a', 'e', 'f', 'h', 'r', 't']: ('father', 'afther') ['b', 'k', 'o', 'o']: ('book', 'boko')
# ['e', 'i', 'l', 'v']: ('evil', 'live', 'levi')


groups = group_anagrams(['evil', 'father', 'book', 'stepik', 'beegeek'])
print(*groups)
# ('beegeek',) ('book',) ('evil',) ('father',) ('stepik',)

groups = group_anagrams(['крона', 'сеточка', 'тесачок', 'лучик', 'стоечка', 'норка', 'чулки'])
print(*groups)
# ('крона', 'норка') ('сеточка', 'тесачок', 'стоечка') ('лучик', 'чулки')


#  10.11-6
"""
Функция ranges() 🌶️
Будем считать, что последовательность целых неотрицательных чисел можно преобразовать в отрезок, 
если разница между соседними элементами этой последовательности равна единице. 
Например, числа 3,4,5,6,7,8 можно преобразовать в отрезок [3;8]. 
Числа 1,3,5,11,15,22 в отрезок преобразовать нельзя. 
Одиночное число преобразуется в отрезок, в котором и правой, и левой границей является оно само. 
Например, число 1 можно преобразовать в отрезок [1;1]

Реализуйте функцию ranges(), которая принимает один аргумент:
numbers — список различных натуральных чисел, расположенных в порядке возрастания
Функция должна преобразовывать числа из списка numbers в отрезки, представляя их в виде кортежей, 
где первый элемент кортежа является левой границей отрезка, 
второй элемент — правой границей отрезка. 
Полученные кортежи-отрезки функция должна возвращать в виде списка.
"""
from itertools import groupby

def ranges(numbers):
    data = groupby(numbers,  key=lambda x: x - numbers.index(x))
    res = (tuple(v) for _, v in data)
    return [(el[0], el[-1]) for el in res]


numbers = [1, 2, 3, 4, 7, 8, 10]
print(ranges(numbers))
# [(1, 4), (7, 8), (10, 10)]

numbers = [1, 3, 5, 7]
print(ranges(numbers))
# [(1, 1), (3, 3), (5, 5), (7, 7)]

numbers = [1, 2, 3, 4, 5, 6, 7]
print(ranges(numbers))
# [(1, 7)]
