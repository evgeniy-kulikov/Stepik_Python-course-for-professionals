# 10.6 Генераторы
""""""


"""   *   *   *   Task   *   *   *   """


#  10.6-1
"""
Доступна генераторная функция cubes_of_odds(), принимающая в качестве аргумента итерируемый объект, 
элементами которого являются целые числа, и возвращающая генератор, 
порождающий последовательность нечетных чисел переданного итерируемого объекта, возведенных в третью степень.

Перепишите данную функцию с использованием генераторного выражения, чтобы она выполняла ту же задачу.
"""
# def cubes_of_odds(iterable):
#     for number in iterable:
#         if number % 2:
#             yield number ** 3

def cubes_of_odds(iterable):
    return (el ** 3 for el in iterable if el % 2)


print(*cubes_of_odds([1, 2, 3, 4, 5]))
# 1 27 125


#  10.6-2
"""
Реализуйте функцию is_prime() с использованием генераторных выражений, которая принимает один аргумент:
number — натуральное число
Функция должна возвращать True, если число number является простым, или False в противном случае.
* Простое число — натуральное число, 
  имеющее ровно два различных натуральных делителя — единицу и самого себя.
  2 3 5 7 11 13 ...
"""
def is_prime(n):
    if n == 2:
        return True
    if n % 2 == 0 or n == 1:
        return False
    return all(n % i for i in range(3, (n // 2) + 1, 2))

print(is_prime(7))  # True
print(is_prime(8))  # False


#  10.6-3
"""
Реализуйте функцию count_iterable() с использованием генераторных выражений, которая принимает один аргумент:
iterable — итерируемый объект
Функция должна возвращать единственное число — количество элементов итерируемого объекта iterable.
*  Гарантируется, что передаваемый в функцию итерируемый объект является конечным
"""
def count_iterable(iterable):
    return sum(1 for _ in iterable)


print(count_iterable([1, 2, 3, 4, 5]))  # 5

data = zip('beegeek', 'stepik')
print(data)  # <zip object at 0x00000257AA242200>
print(count_iterable(data))  # 6


#  10.6-4
"""
Реализуйте функцию all_together() с использованием генераторных выражений, 
которая принимает произвольное количество позиционных аргументов, каждый из которых является итерируемым объектом.
Функция должна возвращать генератор, порождающий каждый элемент всех переданных итерируемых объектов: 
сначала все элементы первого итерируемого объекта, затем второго, и так далее.
* Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
"""
def all_together(*args):
    return (el for arg in args for el in arg)
    # for arg in args:
    #     for el in arg:
    #         yield el

# def all_together(*args):
#     for el in args:
#         yield from el



objects = [range(3), 'bee', [1, 3, 5], (2, 4, 6)]
print(*all_together(*objects))
# 0 1 2 b e e 1 3 5 2 4 6


#  10.6-5
"""
Реализуйте функцию interleave() с использованием генераторных выражений, 
которая принимает произвольное количество позиционных аргументов, 
каждый из которых является последовательностью.

Функция должна возвращать генератор, порождающий каждый элемент всех переданных последовательностей: 
сначала первый элемент первой последовательности, затем первый элемент второй последовательности, и так далее; 
после второй элемент первой последовательности, затем второй элемент второй последовательности, и так далее.

* Последовательностью является коллекция, поддерживающая индексацию и имеющая длину. 
  Например, объекты типа list, str, tuple являются последовательностями.
* Гарантируется, что все последовательности, передаваемые в функцию, имеют равные длины.
* Гарантируется, что в функцию всегда подается хотя бы одна последовательность.
"""
def interleave(*args):
    return (el for arg in zip(*args) for el in arg)

def interleave(*args):
    return (el[idx] for idx in range(len(args[0])) for el in args)


print(*interleave('bee', '123'))
# b 1 e 2 e 3

numbers = [1, 2, 3]
squares = [1, 4, 9]
qubes = [1, 8, 27]
print(*interleave(numbers, squares, qubes))
# 1 1 1 2 4 8 3 9 27
